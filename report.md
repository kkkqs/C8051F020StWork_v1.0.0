一、	设计思路
本系统的软件架构采用分层设计与有限状态机相结合的方式，将整个电梯控制程序划分为硬件抽象层、中间驱动层和应用任务层三个层次。硬件抽象层封装了C8051F020单片机的底层操作，包括定时器初始化、GPIO配置和延时函数等，上层模块调用这些标准化接口即可完成硬件操作，无需关心具体的寄存器配置细节。中间驱动层基于硬件抽象层构建各类外设驱动，如LED数码管驱动负责将显示数据转换为段码并通过Timer1中断实现动态扫描刷新，LCD1602驱动封装了液晶屏的指令和数据写入时序，按键输入驱动实现矩阵键盘的扫描、消抖和键值确认。应用任务层实现具体的业务逻辑，main.ASM作为系统调度中心，根据当前状态将控制权分发给运行任务或配置任务处理。
系统状态管理采用双层状态机架构。主状态机通过RAM地址070h存储当前系统状态，用于区分运行模式、配置菜单、密码验证等不同工作场景。当系统处于运行模式时，电梯控制子状态机接管流程，进一步细分为待机、运行、到达开门和关门四个子状态。状态码的编码规则是高4位表示状态类别、低4位表示具体序号，例如0x00表示运行模式入口、0x20至0x23表示电梯的四个子状态、0x01和0x11至0x13表示配置相关状态、0x02表示密码验证状态。这种编码方式便于通过位操作快速判断当前处于哪类状态。
状态切换检测采用当前状态与上次状态对比的方法。系统使用071h存储上一次循环时的状态值，每次进入状态处理函数时，首先比较070h和071h是否相等，若不相等说明发生了状态切换，此时执行该状态的初始化代码，包括刷新LCD显示内容、重置相关变量等，执行完毕后将当前状态值写入071h；若两者相等则直接执行正常的状态处理逻辑。这种机制确保状态初始化代码只在进入状态时执行一次，避免了重复操作，也无需设置额外的初始化完成标志位。
主循环采用轮询式调度机制。程序在LOOP标签处持续循环执行，每次循环首先调用KeyInput_Process进行按键扫描和消抖处理，然后读取070h中的状态码，通过一系列CJNE指令链式判断当前状态，跳转到对应的任务处理函数。若状态码为0x00或0x20至0x23则调用RunningTask_Handler处理电梯运行逻辑，若为0x01、0x02或0x11至0x13则调用ConfigurationTask_Handler处理配置和密码验证逻辑。任务处理函数执行完毕后返回主循环继续下一轮调度，保证系统对按键事件的快速响应。
模块间通信采用共享RAM变量的方式。按键驱动将确认后的键值写入060h，同时将061h置为01h表示有新的按键事件待处理。状态处理函数检测到061h非零时读取060h获取键值并执行相应操作，处理完成后将061h清零表示事件已消费。这种生产者消费者模式避免了按键事件的丢失或重复处理。显示数据通过028h至02Dh的六字节缓冲区传递给LED驱动，Timer1中断服务程序周期性读取缓冲区内容并轮流点亮六位数码管实现动态显示。电梯控制变量包括当前楼层056h、状态计时器057h、目标楼层058h和秒计数器059h，由Timer0中断服务程序每10毫秒更新一次，实现精确的时序控制。
电梯呼叫请求采用位图方式存储。系统支持11个楼层从负2层到8层，每个楼层对应位图中的一个比特位，三个请求队列分别存储内呼请求、外呼上行请求和外呼下行请求，每个队列仅需两字节即可表示所有楼层的请求状态。楼层与位索引的映射关系为负2层对应bit0、负1层对应bit1、1层对应bit2，以此类推8层对应bit10。这种设计使得请求的置位、清除和检查操作都能在常数时间内完成，且内存占用极小。电梯调度采用SCAN算法，首先沿当前运行方向扫描寻找内呼请求或同向外呼请求，若未找到则从边界位置向反方向扫描寻找反向外呼请求，确保电梯沿一个方向服务完所有请求后再掉头，减少无效的往返运行。
定时器中断承担后台任务的执行。Timer0配置为10毫秒周期的系统心跳，中断服务程序中更新按键消抖计数器和长按计时器，同时累加秒计数器059h，每累计100次即为1秒，届时递减状态计时器057h，当计时器归零时根据当前电梯子状态执行相应的状态切换，如运行状态切换到到达状态、到达状态切换到关门状态、关门状态切换回待机状态。Timer1以约1毫秒的周期触发中断，每次中断点亮一位数码管并递增扫描索引，六位数码管轮流点亮实现动态显示，人眼视觉暂留效应使其看起来像是同时点亮。Timer2配置为自动重装载模式，通过改变重装载值产生不同频率的方波输出，驱动无源蜂鸣器发出不同音调，用于播放提示音或音乐。
二、	资源分配
本系统基于C8051F020单片机，对片上资源进行了严格的规划与分配，以满足多任务并行处理（按键扫描、数码管刷新、LCD显示、电梯逻辑控制、音乐播放）的需求。
3.1 硬件资源分配 (Hardware Resource Allocation)
资源名称	描述	用途/功能	配置详情
Timer 0	定时器0	系统心跳
逻辑控制	工作在模式1（16位定时器），周期 10ms。
负责： 1. 全局时间基准（Tick）
2. 键盘长按/消抖计时
3. 电梯运行状态计时（每100次Tick为1秒）
Timer 1	定时器1	数码管动态扫描	工作在模式1（16位定时器）。作为低频中断源，定期调用 LED6_Refresh 刷新6位8段数码管。
Timer 2	定时器2	无源蜂鸣器驱动	
工作在自动重装载模式（Auto-Reload）。通过改变重装载值（RCAP2H/L）产生不同频率的PWM波，用于播放音乐。
P0 端口	P0.0 - P0.7	数码管段码数据	输出8段字形码（段选）。
P1 端口	P1.0 - P1.7	矩阵键盘接口	连接4x4矩阵键盘，采用行扫描法读取键值。
P2 端口	P2.2 - P2.7	数码管位选控制	控制6位数码管的公共端（位选）。
P3 端口	P3.0 - P3.7	LCD1602 数据总线	8位并行数据传输接口。
P4 端口	P4.5	蜂鸣器输出	输出PWM波形驱动蜂鸣器。
	P4.6	LCD RS	LCD1602 指令/数据选择信号。
	P4.7	LCD E	LCD1602 使能信号。
3.2 存储器资源分配 (Memory Resource Allocation)
系统主要使用内部数据存储器（DATA/IDATA）来维护全局状态、任务通信和硬件缓冲区。主要变量分配如下表所示：
地址范围	变量标识 (Label)	功能描述
0x28 - 0x2D	(Display Buffer)	LED数码管显存。存放当前6位数码管显示的原始数据（字形码索引）。
0x38	-	LED扫描索引。记录当前正在刷新的数码管位（0-5）。
0x39	-	密码输入光标。记录在密码验证界面当前输入的位置。
0x3B	-	配置输入光标。记录在参数配置界面当前操作的数码管位。
0x40 - 0x41	-	键盘坐标。存放最近一次按键的行号和列号。
0x44	-	按键采样值。存放矩阵键盘扫描的原始键值，用于消抖比较。
0x45	-	消抖计数器。记录按键信号稳定的周期数。
0x46	-	按键确认值。经消抖确认后的有效键值。
0x47 - 0x48	-	长按计时器。用于识别按键长按事件（如长按加速调节）。
0x56	CUR_FLr	当前楼层。电梯当前所在的楼层数值。
0x57	ELEV_TIMER	电梯状态计时器。用于状态机的倒计时（如开门保持5秒）。
0x58	ELEV_TARGET	目标楼层。电梯当前正在前往的楼层。
0x59	ONE_SEC_CNT	秒计数器。Timer0中断中每累加100次（1秒）清零一次。
0x5C - 0x5D	INT_REQ	内呼请求队列。位图（Bitmap）形式存储各楼层的内部按键请求。
0x5E - 0x5F	EXT_UP	外呼上行队列。位图形式存储外部的上行请求。
0x60	-	按键事件队列。主循环取用的最终键值（低4位有效）。
0x61	-	按键标志位。1 = 有新按键待处理，0 = 空闲。
0x62 - 0x63	EXT_DN	外呼下行队列。位图形式存储外部的下行请求。
0x64	ELEV_DIR	运行方向。0=停止，1=上行，2=下行。
0x65	INPUT_MODE	输入模式。0=梯内控制模式，1=梯外呼叫模式。
0x70	(System State)	系统主状态机。指示当前是运行、配置还是密码验证模式。
0x71	-	全局刷新标志。置位时强制更新LCD/LED显示内容。
3.3 系统状态机定义 (State Machine Definitions)
为了实现清晰的逻辑分层，系统采用分层状态机结构：主任务状态机负责模式切换，子任务（RunningTask）状态机负责具体的电梯动作。
1. 主任务状态 (Main Task States) - 存储于 RAM 0x70
?	0x00 RUN_ST (运行态): 系统正常工作，响应电梯呼叫与控制。
?	0x01 OPT_ST (配置菜单): 进入参数配置主菜单。
?	0x02 PASS_ST (密码验证): 提示用户验证管理员密码。
?	0x11 OPT1_ST (设置项1): 配置内呼/外呼模式。
?	0x12 OPT2_ST (设置项2): 系统参数设定。
?	0x13 OPT3_ST (设置项3): 修改系统密码。
2. 电梯控制分状态 (Elevator Sub-states) - 复用 RAM 0x70 (在 RUN_ST 下)
?	0x20 ELEV_ST (待机/停止): 电梯静止，等待新的呼叫请求。
?	0x21 ELEV_RUN (运行中): 电梯电机启动，正在楼层间移动。
?	0x22 ELEV_ARRIVED (到达/开门): 电梯到达目标楼层，执行开门动作（保持5秒）。
?	0x23 ELEV_CLOSE (关门中): 门正在关闭，准备进入下一状态（保持2秒）。


-------------------------------------------------------------------------------------------------------------

LCD
硬件上将P3作为数据口与LCD相连，所以其核心工作原理是通过操作 并口数据总线 (P3) 和 控制引脚 (RS, E) 来与 LCD 进行通信。由于 C8051F020 的特殊结构（扩展了更多P口），代码中包含关于 SFR 分页 (SFRPAGE) 的处理。
1. 硬件抽象层与 SFR 分页管理
C8051F020 的寄存器数量超过了标准 8051 的寻址范围，因此采用了“分页”机制。
?	定义的引脚：
o	LCD_RS (P4.6)：寄存器选择信号（0=命令，1=数据）。
o	LCD_E (P4.7)：使能信号，下降沿触发数据锁存。
o	LCD_BUS (P3)：8位数据总线。
?	页切换逻辑（LCD_SET_RS 等子程序）：
由于 P4 端口位于 SFR 页 0Fh，而标准端口位于页 00h。每次操作控制引脚（RS 或 E）时，遵循以下步骤：
o	保存当前累加器 A (PUSH ACC)。
o	切换到 0Fh 页 (MOV SFRPAGE, #0Fh)。
o	修改 P4 端口电平。
o	切回 00h 页 (MOV SFRPAGE, #00h)。
o	恢复累加器 A。
2. 初始化流程 (LCD_INIT)
这是 LCD 上电后必须执行的第一步：
1.	配置 GPIO：切换到 0Fh 页，将 P4.6 和 P4.7 置为1，设为 推挽输出 (Push-Pull)，以确保驱动能力。
2.	上电延时：调用 DELAY_MS 等待 50ms，让 LCD 电压稳定。
3.	发送模式设置 (0x38)：连续两次发送 38h。配置 LCD 为 8位数据总线、双行显示、5x7 点阵字符。
4.	显示开关控制 (0x0C)：开启显示，关闭光标，关闭光标闪烁。
5.	输入模式设置 (0x06)：设置文字写入后地址指针自动加1（文字从左向右显示），且屏幕不滚动。
6.	清屏 (0x01)：清除屏幕内容。
3. 写操作流程 (LCD_WR_CMD / LCD_WR_DAT)
这是驱动的核心，实现了时序控制：
?	步骤 1：区分类型
o	若是写 命令 (LCD_WR_CMD)：调用 LCD_CLR_RS 拉低 RS 引脚。
o	若是写 数据 (LCD_WR_DAT)：调用 LCD_SET_RS 拉高 RS 引脚。
?	步骤 2：写入总线与产生脉冲 (LCD_WR_COM)
o	MOV LCD_BUS, A：将要发送的字节放到 P3 数据总线上。
o	LCALL LCD_SET_E：将 E 引脚拉高（高电平使能）。
o	NOP：空指令延时，确保脉冲宽度足够。
o	LCALL LCD_CLR_E：将 E 引脚拉低。LCD 在这个下降沿读取数据。
o	LCALL DELAY_MS：等待 LCD 内部处理完成（LCD 速度较慢，必须等待）。
4. 高级应用函数
?	清屏 (LCD_CLEAR)：
直接调用写命令函数发送指令 01h。
?	显示字符串 (LCD_SHOW_STR)：
利用 DPTR 指针遍历字符串数据：
o	MOVC A, @A+DPTR：从代码区读取字符。
o	JZ LCD_STR_END：如果读到 00h (字符串结束符)，则退出。
o	 LCALL LCD_WR_DAT：将字符写入 LCD 显示。
o	 INC DPTR：指针加 1，跳转循环处理下一个字符。
LED
硬件上用P0和P2口控制，实现了 6位 LED 数码管 的 动态扫描显示 驱动。其核心原理是利用人眼的 视觉暂留效应。由于 I/O 口有限，不能同时点亮所有数码管，所以代码快速轮流点亮每一位数码管。只要切换速度够快，人眼看去就是所有数码管同时亮起的。
1. 核心刷新机制 (LED6_Refresh)
这个函数通常被定时器中断（ISR）反复调用。每次被调用时，它只负责刷新 其中一位 数码管。
?	步骤 1：消隐 (Ghosting Elimination)
o	MOV P0, #0FFh / MOV P2, #0FFh
o	在切换下一位之前，先强制关闭所有段选（P0）和位选（P2）。
o	原因：如果直接切换，上一位的残影会出现在下一位上。先全部熄灭再切换，可以消除这种“鬼影”。
?	步骤 2：读取显示缓冲
o	MOV A, 038h：读取当前的扫描索引（Index），决定是哪一位数码管。
o	ADD A, #028h：计算显存地址。显存缓冲区从 RAM 地址 0x28 开始（0x28~`0x2D`）。
o	MOV A, @R0：读出当前这一位应该显示的“逻辑数字”（比如数字 1, 2, 3）。
?	步骤 3：段码查找 (Segment Translation)
o	MOV DPTR, #SEG_TABLE
o	MOVC A, @A+DPTR
o	将逻辑数字转换为 7段数码管的物理电平组合。
o	转换后的结果存入 P0 (MOV P0, A)，控制数码管的显示的形状。
?	步骤 4：位码查找与生成 (Digit Selection)
o	MOV DPTR, #BITMASK_TABLE
o	MOVC A, @A+DPTR
o	查表获取当前应该点亮哪一个数码管（位选掩码）。
o	CPL A：取反。
o	原理：电路中位选接 PNP 三极管，低电平有效。查表出来通常是高电平有效，所以要取反变成低电平来导通三极管，点亮该位。
o	结果存入 P2，真正点亮数码管。
?	步骤 5：索引递增
o	INC 038h：索引加 1，准备下次点亮下一位。
o	CJNE A, #06, LED6_EXIT：如果索引到了 6，就清零回到 0，形成循环扫描。
2. 显示内容更新机制 (LED6_ApplyTable)
这个函数用于一次性更新整个屏幕显示的内容，比如从显示“OPEN”切换到显示“Err 01”。
?	步骤 1：查表选择
o	根据输入的 A（表 ID，例如 01h 代表 RUN 状态），通过一系列 CJNE指令，找到对应的预定义显示内容表。
?	步骤 2：数据拷贝 (Copy Loop)
o	确定源地址（DPTR）和目标地址（RAM 0x28）。
o	进入循环 LBL_LOOP：
1)	MOVC A, @A+DPTR：从代码区的表格里读一个字节。
2)	MOV @R0, A：写入到 RAM 显存 (0x28 开始)。
3)	INC R0 / INC R3：指针后移。
o	循环 6 次，填满 6 个位置。
RUNNING TASK 停靠LCD、LED显示+开关门
1. 触发抵达（状态切换）
当电梯运行中 (ELEV_RUN_HANDLER) 检测到当前楼层 (CUR_FLr) 有请求时：
1)	清除请求：调用 CLEAR_FLOOR_REQUEST 清除该楼层的按钮记录。
2)	设置状态：将状态变量 070h 设置为 #ELEV_ARRIVED（到站/开门状态）。
3)	设置定时器：MOV ELEV_TIMER, #05h，设置开门保持时间为 5 秒。
4)	强制刷新：MOV 071h, #0FFh，通知显示模块进行一次全屏刷新。
2. 开门阶段 (ELEV_ARRIVED_HANDLER)
这是电梯停稳后门打开的状态。
A. 初始化显示 (EA_INIT)
进入该状态的第一刻，执行初始化：
?	LCD 显示：
o	调用 LCD_CLEAR 清屏。
o	调用 LCD_SHOW_STR 显示字符串 LCD_MSG_OPEN，即屏幕显示文本：" open door "。
B. 循环检测与 LED 闪烁 (EA_BLINK_LOGIC)
在 5 秒倒计时期间，主循环不断执行 EA_BLINK_LOGIC：
?	闪烁原理：
o	读取 ONE_SEC_CNT（毫秒计数器）。
o	若计数器 < 50 (即 0.5秒内)：显示 "OP"。
?	向显存 028h, 029h 写入字符 '0.', 'P.'。
o	若计数器 >= 50 (即后 0.5秒)：熄灭。
?	向显存 028h, 029h 写入空格 #37。
o	这就形成了数码管前两位 "OP" 闪烁的效果。
?	楼层显示：
o	将当前楼层 CUR_FLr 写入显存 02Ch, 02Dh（数码管后两位），保持常亮。
C. 按键检测
?	关门键 ('D')：检测到按键 0Dh，立即将状态改为 #ELEV_CLOSE，并将时间设为 2秒（加速关门）。
?	其他请求：调用 CHECK_AND_SET_REQUEST 继续记录其他楼层的呼叫。
3. 关门阶段 (ELEV_CLOSE_HANDLER)
当开门 5 秒倒计时结束，或按下了关门键，进入此状态。
A. 初始化显示 (EC_INIT)
?	LCD 显示：
o	调用 LCD_CLEAR 清屏。
o	显示字符串 LCD_MSG_CLOSE，即屏幕显示文本：" close door "。
B. 循环检测与 LED 闪烁 (EC_BLINK_LOGIC)
与开门类似，在 2 秒关门时间内：
?	闪烁原理：
o	根据 ONE_SEC_CNT 切换显示。
o	亮时：向显存 028h, 029h 写入 'C', 'L' (Close)。
o	灭时：写入空格。
o	形成数码管前两位 "CL" 闪烁的效果。
?	楼层显示：
o	在此阶段，代码中将后两位 02Ch, 02Dh 设为了空格（不显示楼层）。
C. 重开门检测
?	开门键 ('C') 或 本层外呼：
o	如果检测到按键 0Ch 或者有人在当前楼层按了按钮。
o	立即跳转回 EH_OPEN_NOW (重置为 ELEV_ARRIVED 状态)。
o	重置定时器为 5 秒，实现“重新开门”功能。
4. 回归待机或继续运行
当关门时间（2秒）结束（ELEV_TIMER 减为 0）：
1)	判断逻辑：代码会检查是否还有其他楼层的请求 (SCAN_FIND_NEXT_TARGET)。
2)	有请求：状态转为 ELEV_RUN，LCD 显示 "Running..."，LED 显示U/d和目标楼层。
3)	无请求：状态转为 ELEV_ST (待机)，LCD 显示 "Welcome" 和当前楼层
5. 待机状态
此时电梯处于 ELEV_ST 状态（待机），门是关着的。LED显示“FL“当前楼层
A. 检测内部开门键
?	操作：
1)	检查 061h（按键标志位）是否为非零（有按键按下）。
2)	读取 060h（键值），屏蔽高 4 位 (ANL A, #0Fh)，只看低 4 位。
3)	判断是否等于 #0Ch（即键盘矩阵上的 'C' 键，定义为 Open）。
?	结果：
o	如果按下了 'C' 键，直接跳转到 EH_OPEN_NOW。
o	效果：电梯不做任何移动，你在轿厢按开门 'C'键，直接在当前楼层重新打开门（进入步骤 2 的开门流程）。
B. 检测当前楼层呼叫（内选或外呼）
?	操作：
1)	将当前楼层 CUR_FLr 存入寄存器 R6。
2)	调用 CHECK_FLOOR_REQUEST：去查一下请求列表（内选 BitMap 或 外呼 BitMap），看看有没有人正在当前这个楼层按按钮。
?	结果：
o	如果 CHECK_FLOOR_REQUEST 返回进位位 C=1（表示有请求）：
1)	调用 CLEAR_FLOOR_REQUEST：把这个请求清除掉（因为电梯就在这儿，马上就给你开门）。
2)	跳转到 EH_OPEN_NOW。
o	效果：如果你站在 1 楼电梯口，电梯也就停在 1 楼，你按一下墙上的“上/下”按钮，电梯立刻开门。
C. 进入开门流程 (EH_OPEN_NOW)
无论是按了 'C' 键还是按了当前楼层钮，最终都汇聚到这里：
1)	状态切换：MOV 070h, #ELEV_ARRIVED。
2)	设置时间：MOV ELEV_TIMER, #05h，开始倒计时。
3)	防止连击：MOV 061h, #00h（把刚才触发开门的那个按键消耗掉，防止关门时又读到它）。
4)	强制刷新：MOV 071h, #0FFh。

-------------------------------------------------------------------------------------------------------------

2. 定时器驱动设计
本系统使用了两个定时器：Timer0 作为系统的主要心跳（Tick），用于任务调度和计时功能；Timer1 用于数码管的动态扫描刷新。
2.1 Timer0 驱动设计 (bsp/timer0.asm)
Timer0 被配置为系统时基发生器，提供 10ms 的定时中断。
?	初始化配置 (Timer0_Init)：
o	设置定时器初值，计数器初值为 0xD8F0。
o	在 16MHz 晶振（或系统时钟配置）下，溢出周期约为 10ms。
o	开启定时器中断 ET0 和全局中断 EA。
?	中断服务服务程序 (TIMER0_ISR)：
o	重装载初值：手动重装载 TH0 和 TL0 以保持 10ms 周期。
o	核心功能：
a.	按键长按检测：配合键盘模块，通过寄存器 047h 进行计数，实现按键的长按判断逻辑。
b.	系统时间维护：通过 ONE_SEC_CNT (059h) 计数实现秒级计时。
c.	电梯运行控制：在 ISR 中处理电梯状态机的部分时序逻辑，例如电梯移动过程中的楼层更新检测和开关门延时递减 (057h)。
2.2 Timer1 驱动设计 (bsp/timer1.asm)
Timer1 专门用于驱动 6 位数码管的动态显示，利用人眼的视觉暂留效应实现多位显示。
?	初始化配置 (Timer1_Init)：
o	配置 TMOD 寄存器为 #011h，设置 Timer1 为 16 位定时器模式。
o	初值设置为 TH1 = #0FCh, TL1 = #018h，产生较高频率的中断以保证扫描不闪烁。
o	开启 Timer1 中断。
?	中断服务程序 (TIMER1_ISR)：
o	保护现场。
o	重装载初值。
o	调用外部驱动函数 LED6_Refresh（位于 driver/LED6.asm），完成当前位选和段码的输出刷新。
o	恢复现场并返回。
3. 键盘驱动设计 (bsp/Keyboard.asm)
系统采用 4x4 矩阵键盘作为人机交互输入设备。本驱动层主要负责底层的电平扫描，将物理按键映射为键值。
?	硬件连接：
o	键盘采用行列式连接，连接在 P1 口。
o	高 4 位（P1.7-P1.4）作为输入检测（行或列）。
o	低 4 位（P1.3-P1.0）作为扫描输出（列或行）。
?	扫描算法 (MatrixKey)：
o	原理：要采用“逐列扫描法”（或逐行）。
o	实现流程：
a.	初始状态将 P1 口置高。
b.	第一轮扫描：拉低 P1.3，检测 P1.7-P1.4 的状态。如果发现低电平，说明对应行有按键按下，根据位置返回对应键值（如 0Fh, 0Eh, 0Dh, 0Ch）。
c.	后序扫描：依次拉低 P1.2, P1.1, P1.0，重复上述检测步骤。
o	返回值：
?	累加器 A：返回检测到的键值（1-16）。
?	若无按键按下，返回 0FFh。
?	辅助调试信息：寄存器 040h 存储行号，041h 存储列号，方便后续状态机调用或调试。4. 空闲自动停泊功能设计
为了提升电梯系统的能效和响应速度，本系统实现了智能空闲停泊功能。当电梯处于待机状态（无任何呼叫请求）时，系统会根据当前位置自动将电梯移动到预设的停泊楼层（1楼或8楼），以优化整体候梯时间。
4.1 功能触发机制
空闲停泊功能由运行任务状态机（Tasks/runningTask.asm）中的待机状态处理器（ELEV_HANDLER）统一管理：
?	触发条件判断：
o	系统通过 SCAN_FIND_NEXT_TARGET 函数扫描所有请求队列（内呼 INT_REQ、外呼上行 EXT_UP、外呼下行 EXT_DN）。
o	若返回进位标志 C=0，表示所有队列均为空，无任何待处理请求。
o	此时进入 ELEV_NO_REQ 分支，检查电梯状态计时器 (ELEV_TIMER, 057h)。
?	等待周期设置：
o	为避免频繁启停，系统设置了缓冲等待时间。当进入空闲状态时，ELEV_TIMER 被初始化为非零值（具体值由状态机逻辑决定）。
o	Timer0 中断服务程序每秒递减一次 ELEV_TIMER。
o	仅当 ELEV_TIMER 归零时（表示已空闲一定时间），才会触发停泊逻辑 (ELEV_CHECK_PARK)。
4.2 智能停泊楼层选择算法
系统采用基于当前位置的就近停泊策略，以最小化移动距离：
?	楼层索引映射：
o	调用 FLOOR_TO_INDEX 将当前楼层 (CUR_FLr, 056h) 转换为线性索引 R4。
o	索引范围：负2层→索引0，负1层→索引1，1楼→索引2，...，8楼→索引9。
?	分界点判断 (ECP_TEST)：
o	系统以索引6（对应4/5楼之间）为分界点。
o	若当前索引 R4 < 6（电梯位于低层区）：目标停泊楼层设为 1楼 (R6 ← 01h)。
o	若当前索引 R4 ≥ 6（电梯位于高层区）：目标停泊楼层设为 8楼 (R6 ← 08h)。
?	执行逻辑 (ECP_EXEC)：
o	比较目标楼层 R6 与当前楼层 CUR_FLr。
o	若已在目标停泊楼层：设置 ELEV_DIR ← 00h（方向停止），保持待机状态。
o	若不在目标停泊楼层：跳转到 ELEV_DIFF，启动电梯移动流程。
4.3 移动流程与显示反馈
一旦确定需要移动到停泊楼层，系统执行标准的电梯运行流程：
1.	设置目标楼层：ELEV_TARGET ← R6（停泊楼层）。
2.	计算运行方向与时间：
o	通过楼层索引比较确定方向（上行/下行）。
o	根据索引差值设置 ELEV_TIMER（每秒移动一层）。
3.	状态切换：将系统状态 (070h) 切换为 ELEV_RUN（运行中）。
4.	LCD显示更新：
o	清屏并显示 "Running..."。
o	数码管显示运行方向（'U' 或 'd'）和目标楼层。
5.	自动停靠：
o	Timer0 中断服务程序监控电梯移动进度，每秒更新 CUR_FLr。
o	当 CUR_FLr 达到 ELEV_TARGET 时，自动切换到 ELEV_ARRIVED 状态（开门）。
o	开门保持5秒后，进入 ELEV_CLOSE 状态（关门2秒），最终返回 ELEV_ST（待机）。
4.4 与正常运行的协同
停泊过程中，系统保持对新请求的响应能力：
?	中断优先级：
o	停泊移动过程中，按键扫描和消抖逻辑仍在 Timer0 ISR 中正常执行。
o	若用户在停泊途中按下任何楼层按钮，CHECK_AND_SET_REQUEST 函数会立即更新请求队列。
?	动态重调度：
o	运行状态处理器 (ELEV_RUN_HANDLER) 在每次主循环迭代中检查当前楼层是否有请求 (CHECK_FLOOR_REQUEST)。
o	若检测到途中停靠请求，立即清除请求并切换到 ELEV_ARRIVED 状态，执行正常的开关门流程。
o	关门后重新进入 SCAN_FIND_NEXT_TARGET 调度，优先处理实际用户请求，停泊逻辑自动挂起。
4.5 实现效果
?	节能优化：避免电梯长时间停在中间楼层，减少两端用户的平均候梯时间。
?	智能分配：根据当前位置就近停泊，避免不必要的长距离移动。
?	无缝切换：停泊过程与正常运行流程完全共享状态机逻辑，保证系统稳定性。
?	用户透明：对用户而言，停泊过程与普通楼层移动无异，LCD和LED显示保持一致的交互反馈。
5. 交互模式与动态调度增强
为了真实模拟电梯在实际使用中的“梯内选层”与“梯外呼叫”两种截然不同的操作场景，本系统在 RunningTask 中实现了双重输入模式及其切换逻辑，并增强了电梯运行过程中的实时响应能力。
5.1 双重输入模式设计 (Inside/Outside Mode)
系统利用 065h 单元存储当前的输入模式变量 INPUT_MODE，并通过矩阵键盘的特殊按键进行动态切换，解决了有限按键无法覆盖所有楼层上下行呼叫的难题。
?	模式切换机制：
o	在 CHECK_AND_SET_REQUEST 函数中，系统持续检测 'A' 键 (0x0A)。
o	一旦检测到 'A' 键按下，立即对 INPUT_MODE 执行异或操作 (XRL A, #01h)，在 0 (梯内模式) 和 1 (梯外模式) 之间切换。
o	LCD 屏幕会根据模式实时更新提示信息：梯内模式显示 "Inside"，梯外模式显示 "Out: " 及当前选择的楼层。
?	梯内控制模式 (Inside Mode)：
o	逻辑：模拟乘客在电梯轿厢内按键。
o	操作：用户直接按下数字键 (0-9)，系统立即将对应楼层置入内呼请求队列 (INT_REQ)，触发电梯响应。
?	梯外呼叫模式 (Outside Mode)：
o	逻辑：模拟乘客在不同楼层的电梯厅按压“上/下”按钮。
o	操作：采用“先选层、后选向”的交互方式。
1.	用户先按下数字键 (0-9) 选择当前所在的楼层，此时请求尚未生效。
2.	用户接着按下 'E' (Up) 或 'F' (Down) 键。
3.	系统根据组合键将请求分别置入外呼上行队列 (EXT_UP) 或外呼下行队列 (EXT_DN)。
5.2 运行中途截停机制 (En-route Interception)
为了提高运输效率，系统在电梯移动过程中实现了“顺向截停”功能的实时检测逻辑，而非简单地移动到目标楼层才停止。
?	实现原理：
o	在 ELEV_RUN_HANDLER (运行状态处理器) 中，电梯每经过一个楼层（即 CUR_FLr 发生变化时），不仅更新显示，还会立即调用 CHECK_FLOOR_REQUEST 函数。
o	检查对象：当前楼层是否存在与运行方向相同的请求（如上行时检查内呼或外呼上行）。
?	截停流程：
o	若检测到有效请求 (Carry Flag = 1)：
1.	立即清除该请求 (CLEAR_FLOOR_REQUEST)。
2.	强制中断当前的移动流程。
3.	将状态机直接切换至 ELEV_ARRIVED (0x22)。
4.	重置 ELEV_TIMER 为 5秒，执行开门动作。
o	这一机制确保了电梯能够像真实电梯一样，灵活地接载沿途乘客，避免了必须先到达终点再折返的低效运行。
--------------------------------------------------------------------------------------------------------------、

一、任务要求 
1. 中间层设计：在KeyInput.asm、KBI.asm和LED6.asm中设计并实现连接底层硬件驱
动（矩阵键盘、数码管、LCD）与上层应用逻辑的中间件。重点解决按键的物理消抖、
输入缓冲区的游标管理以及显示内容的抽象化映射。 
2. 电梯执行逻辑实现：在 RunningTask.asm 中实现电梯的动作执行层，计算运行参数
（方向、时间），控制状态机流转（运行/停止/开关门），并驱动显示层实时反馈电梯状
态。 
3. 输入任务管理：在InputTask.asm中实现基于光标的通用输入任务，支持数字输入、
退格与确认逻辑，用于系统配置及密码验证。 
二、设计思路 
本实验采用分层架构设计，将系统分为驱动层、中间层和应用层。我主要负责中间层及
核心运行任务的实现。 
1. 电梯动作执行（runningTask） 
电梯的运行逻辑是一个复杂的状态机，配合位图存储请求与两轮扫描算法，我们在
runningTask.asm 中 定义了 RUN_ST( 总入口),ELEV_ST( 待机),ELEV_RUN( 运行), 
ELEV_ARRIVED(到达开门),ELEV_CLOSE(关门)这五个主状态；使用位图存储楼层请求，将-2F
至8F映射为Index0~10；设置INT_REQ用于内选请求、EXT_UP/EXT_DN用于外呼上行/下行
请求。 
在电梯调度逻辑方面，我们采用了两轮扫描法。第一轮严格扫描：基于当前方向，寻找
同向的内选或外呼请求，遵循“就近原则”，一旦发现立即响应，实现顺向截停。第二轮宽
松扫描：若同向无请求，则寻找反向的外呼请求。我们采用了由远及近的扫描策略，即向上
寻找反向请求时，从最高层向下扫；向下寻找反向请求时，从最底层向上扫。这确保了电梯
1 
《单片机与嵌入式系统实验》报告                
能响应最远端的反向请求，避免“丢包”现象，最大化运输效率。 
在电梯运动模拟方面，通过比较当前楼层索引（R4）与目标楼层索引（R3）的差值，计
算运行所需的定时器节拍数ELEV_TIMER，并在 Timer0 中断中递减该值以模拟物理耗时。 
2. 按键消抖逻辑 (KeyInput) 
KeyInput.asm 实现了软件消抖，有效滤除了机械触点抖动产生的毛刺。在每次调用时，
先读取物理键值，并与上一次的采样值（044H）对比，如果键值发生变化，则重置计数器 045H；
如果键值保持不变，则计数器累加。当且仅当计数器达到预设的采样阈值（3次）时，才认
为按键有效，并将其写入系统键值缓冲区060H，同时置位标志位061H通知上层任务。 
3. 输入任务 (InputTask) 
InputTask.asm 使得输入逻辑可以复用，例如可以多次进行配置菜单和密码输入。我们
通过 startIndex(020H)和 endIndex(021h)定义输入区域，进行游标管理： 
当系统检测到0-9的键值时，写入当前游标指向的缓冲区，并自动右移游标。 
当系统检测到0x0B键值时，若当前位非空则清除当前位；若当前位为空且未达起始位，
则左移游标并清除，实现了类似PC的退格体验。 
当系统检测到0x0A键值时，触发回调（如密码验证），并返回特定状态码。 
4. 显示抽象层 (LED6) 
为了解耦逻辑与硬件，我们设计了查表式的显示驱动 LED6.asm，这使得上层逻辑只需
传递一个表格ID（如02H代表OPT菜单，07H代表PASS菜单）。 
具体地，LED6_ApplyTable将ID查找到的字模数据批量拷贝到显存缓冲区（028H~02DH），
Timer1 中断定期调用LED6_Refresh，将缓冲区数据输出到数码管端口，这种设计的好处在
于无需改动底层驱动即可修改显示内容。 
三、资源分配 
本部分实验主要使用了以下RAM资源与寄存器： 
1. 全局状态与标志位 
070H：系统主状态机 
071H：状态机刷新标志 
050H~054H：配置参数存储区 
2. 输入系统资源 
060H：有效键值 
061H：按键就绪标志 
2 
《单片机与嵌入式系统实验》报告                
044H~048H：消抖过程变量 
020H、021H：输入任务起始/结束索引 
03BH、039H：当前光标位置指针 
3. 电梯运行核心数据 
056H(CUR_FLr)：当前楼层 
058H(ELEV_TARGET)：目标楼层 
057H(ELEV_TIMER)：运行倒计时定时器 
INT_REQ_LO/HI：内选请求位图 
EXT_UP_LO/HI：外呼上行请求位图 
EXT_DN_LO/HI：外呼下行请求位图 
4. 显示缓冲区 
028H~02DH：6 位 LED 数码管显存
